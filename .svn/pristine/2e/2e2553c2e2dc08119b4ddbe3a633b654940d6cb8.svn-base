package runner.contactlab.com;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.apache.commons.collections4.ListUtils;

import script.contactlab.com.SearchLoadDataRealFileName;
import script.contactlab.com.SearchLoadDataStatement;
import script.contactlab.com.SplitGeneralQueryLogFile;
import script.contactlab.com.TimerConnectionAggregator;

import com.google.inject.Inject;

public class ApplicationRunner {

	private static final String SUB_PATH_LD = "/ld/";
	private static final String SUB_PATH_FILES = "/files/";
	
	private Logger logger;

	@Inject
	public ApplicationRunner(Logger logger) {
		this.logger = logger;
	}

	public void run() throws Exception {
		logger.info("Running ...");

		final Scanner scanner = new Scanner(System.in);
		Integer numberOfThread;

		try {
			logger.info("Number of Thread:");
			numberOfThread = new Integer(scanner.nextLine());
		} catch (NumberFormatException e) {
			logger.error("No number received, add default !!?");

			numberOfThread = 5;
		}
		logger.info("Supplied Number of Thread: " + numberOfThread);

		logger.info("Absolute Path of general query log file: ");
		final String generalLogInput = scanner.nextLine();

		final File generalLog = new File(generalLogInput);
		if (isAccesible(generalLog)) {
			//make dir /files and empty if exist
			final File t = new File(generalLog.getParent() + SUB_PATH_FILES);
			
			if (t.exists()) {
				delete(t);
			}
			
			t.mkdir();
			
			final String filesPath = generalLog.getParent() + SUB_PATH_FILES;
			
			logger.info("Start splitter of general query log file");
			final List<TimerConnectionAggregator> data =
				new SplitGeneralQueryLogFile().run(generalLog.getAbsolutePath(), filesPath);
			
			logger.info("Start search LOAD DATA into general query log file");
			final List<Integer> idsWithLoadData = 
				new SearchLoadDataStatement().run(generalLogInput);
			
			if (idsWithLoadData.isEmpty()) {
				logger.info("Start schedule of " + data.size() + " connection's");
				schedule(numberOfThread, data, filesPath, null);											
			} else {
				logger.info("Absolute Path of binary log file: (mysqlbinlog --verbose bin.000003 > bin.000003.txt)");
				final String binaryLogInput = scanner.nextLine();
				
				final File binaryLog = new File(binaryLogInput);
				if (isAccesible(binaryLog)) {
					
					logger.info("Start searching of real file name of LOAD DATA");
					for (TimerConnectionAggregator tca : data) {
						final List<Integer> intersection = ListUtils.intersection(tca.getIds(), idsWithLoadData);
						final HashMap<Integer, String[]> run = new SearchLoadDataRealFileName().run(intersection, binaryLogInput);
						
						for (Entry<Integer, String[]> e : run.entrySet()) {
							tca.addLoadData(e.getKey(), e.getValue());
						}
					}
					
					logger.info("Start schedule of " + data.size() + " connection's and " + idsWithLoadData.size() + " load data");
					schedule(numberOfThread, data, filesPath, binaryLog.getParent() + SUB_PATH_LD); 																
				} else {
					logger.error("Can't load data from file: " + binaryLogInput);
				}
			}			
		} else {
			logger.error("Can't load data from file: " + generalLogInput);
		}

		scanner.close();
		logger.info("Running ... END'S !!");
	}

	private boolean isAccesible(final File generalLog) {
		return generalLog.exists() && generalLog.canRead();
	}

	private void schedule(int numberOfThread, List<TimerConnectionAggregator> data, String filesPath, String loadDatasPath) {
		final ScheduledExecutorService pool = Executors.newScheduledThreadPool(numberOfThread);

		long current = 0;
		for (TimerConnectionAggregator tca : data) {
			current += tca.getDelay();
			
			pool.schedule(new MyCallable(tca, filesPath, loadDatasPath), current, TimeUnit.MILLISECONDS);
		}
		
		pool.shutdown();
		logger.info("... pool shutdown");
		
		try {
			pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			logger.error(e.getMessage());
		}
		
		logger.info("... after pool awaitTermination");
	}

	private void delete(File file) throws IOException {
		if (file.isDirectory()) {
			// directory is empty, then delete it
			if (file.list().length == 0) {
				file.delete();
			} else {
				// list all the directory contents
				String files[] = file.list();

				for (String temp : files) {
					// construct the file structure
					File fileDelete = new File(file, temp);

					// recursive delete
					delete(fileDelete);
				}

				// check the directory again, if empty then delete it
				if (file.list().length == 0) {
					file.delete();
				}
			}
		} else {
			// if file, then delete it
			file.delete();
		}
	}
}
