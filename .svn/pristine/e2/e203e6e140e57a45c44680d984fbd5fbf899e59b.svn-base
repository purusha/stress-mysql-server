package runner.contactlab.com;

import java.beans.PropertyVetoException;
import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import script.contactlab.com.ApplicationParameter;
import script.contactlab.com.SearchLoadDataRealFileName;
import script.contactlab.com.SearchLoadDataStatement;
import script.contactlab.com.TimerConnectionAggregator;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

public class BruteForceApplicationRunner extends ApplicationRunner {

	@Override
	protected void realRun(final ApplicationParameter params) throws Exception {
		logger.info("Starting ...");		
		final String filesPath = params.getPathOfPayload() + SUB_PATH_FILES;
				
		logger.info("Start search LOAD DATA into general query log file");
		final List<Integer> idsWithLoadData = new SearchLoadDataStatement().run(params.generalQueryLogPath());
		
		logger.info("Start load file name of Connections");
		final List<Integer> connectionFileNames = retriveConnectionFiles(new File(filesPath));
		
		if (idsWithLoadData.isEmpty()) {
			logger.info("Start schedule of " + connectionFileNames.size() + " connection's");
			
			final List<TimerConnectionAggregator>  tcas = Lists.newArrayList();			
			for (Integer fileName : connectionFileNames) {
				tcas.add(new TimerConnectionAggregator(Long.valueOf(0l), Sets.newHashSet(fileName)));
			}
			
			schedule(params.getNumberOfThread(), tcas, filesPath, null, params.getDatabaseServer(), params.getPathOfPayload());											
		} else {
			logger.info("Start searching of real file name of LOAD DATA: " + idsWithLoadData.size());
			
			final HashMap<Integer, String[]> run = new SearchLoadDataRealFileName().run(idsWithLoadData, params.binaryLogDirPath());
			logger.info("Found " + run.keySet().size() + " real file name of LOAD DATA");
			
			final List<TimerConnectionAggregator>  tcas = Lists.newArrayList();			
			for (Integer i : connectionFileNames) {
				final TimerConnectionAggregator tca = new TimerConnectionAggregator(Long.valueOf(0l), Sets.newHashSet(i));
				
				if (run.containsKey(i)) {
					tca.addLoadData(i, run.get(i));
				}
				
				tcas.add(tca);
			}
			
			logger.info("Start schedule of " + connectionFileNames.size() + " connection's and " + idsWithLoadData.size() + " load data");
			schedule(params.getNumberOfThread(), tcas, filesPath, params.loadDataDirPath(), params.getDatabaseServer(), params.getPathOfPayload()); 	
		}
	}
	
	private void schedule(int numberOfThread, List<TimerConnectionAggregator> data, String filesPath, String loadDatasPath, String dbHostName, String generalLogDirPath) {
		final List<Future<PayloadAsync>> futureData = new ArrayList<Future<PayloadAsync>>();				
		final ExecutorService pool = Executors.newFixedThreadPool(numberOfThread);
		
		//XXX make and add shutdown hook
		Runtime.getRuntime().addShutdownHook(new RunWhenShuttingDown(futureData, generalLogDirPath));
		
		try {
			final DataSource ds = buildDataSource(dbHostName);			
			
			for (TimerConnectionAggregator tca : data) {
				futureData.add(
					pool.submit(
						new MyCallable(tca, filesPath, loadDatasPath, ds) 
					)
				);
			}			
		} catch (PropertyVetoException e) {
			logger.error(null, e);
		}
		
		logger.info("thread pool shutdown");
		pool.shutdown();		
		
		try {
			logger.info("thread pool awaitTermination");
			pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			logger.error(null, e);
		}		
	}
	
	private List<Integer> retriveConnectionFiles(final File folder) {
		final List<Integer> result = new ArrayList<Integer>();
		
	    for (final File fileEntry : folder.listFiles()) {
	        if (!fileEntry.isDirectory()) {
	        	try {
		        	final Integer i = Integer.valueOf(fileEntry.getName());
		        	
		        	result.add(i);	        		
	        	} catch (NumberFormatException nfe) {	        			        		
	        	}
	        }
	    }
	    
	    Collections.sort(result);
	    
	    return result;
	}
	
}
