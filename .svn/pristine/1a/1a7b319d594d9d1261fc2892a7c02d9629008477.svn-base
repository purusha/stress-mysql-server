package runner.contactlab.com;

import java.beans.PropertyVetoException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import org.apache.commons.collections4.ListUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import script.contactlab.com.ApplicationParameter;
import script.contactlab.com.ApplicationParameterHandler;
import script.contactlab.com.SearchLoadDataRealFileName;
import script.contactlab.com.SearchLoadDataStatement;
import script.contactlab.com.TimerConnectionAggregator;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class ApplicationRunner {
	private static final Logger logger = LoggerFactory.getLogger(ApplicationRunner.class);
	public static final String SUB_PATH_FILES = "/files/";
	
	public void run() throws Exception {
		logger.info("Give me application parameters ...");
		final ApplicationParameter params = new ApplicationParameterHandler().run();

		realRun(params);		
	}
	
	public void run(ApplicationParameter params) throws Exception {
		realRun(params);
	}
	
//  > VERSION 1	
//	> split general.log in files/*
//  > execute n thread with delay readed by general.log  	 
//	
//	private void realRun(final ApplicationParameter params) throws IOException, Exception {
//		logger.info("Starting ...");		
//		final String filesPath = params.getPathOfPayload() + SUB_PATH_FILES;
//		
//		//make dir /files and empty if exist
//		final File t = new File(filesPath);		
//		delete(t);			
//		t.mkdir();
//		
//		System.out.println("Start splitter of general query log file");
//		final List<TimerConnectionAggregator> data = new SplitGeneralQueryLogFile().run(params.generalQueryLogPath(), filesPath);
//		
//		System.out.println("Start search LOAD DATA into general query log file");
//		final List<Integer> idsWithLoadData = new SearchLoadDataStatement().run(params.generalQueryLogPath());
//		
//		if (idsWithLoadData.isEmpty()) {
//			System.out.println("Start schedule of " + data.size() + " connection's");
//			schedule(params.getNumberOfThread(), data, filesPath, null, params.getDatabaseServer(), params.getPathOfPayload());											
//		} else {
//			logger.info("Start searching of real file name of LOAD DATA");
//			for (TimerConnectionAggregator tca : data) {
//				final List<Integer> intersection = ListUtils.intersection(Lists.newArrayList(tca.getIds()), idsWithLoadData);
//				final HashMap<Integer, String[]> run = new SearchLoadDataRealFileName().run(intersection, params.binaryLogDirPath());
//				
//				for (Entry<Integer, String[]> e : run.entrySet()) {
//					tca.addLoadData(e.getKey(), e.getValue());
//				}
//			}
//			
//			System.out.println("Start schedule of " + data.size() + " connection's and " + idsWithLoadData.size() + " load data");
//			schedule(params.getNumberOfThread(), data, filesPath, params.loadDataDirPath(), params.getDatabaseServer(), params.getPathOfPayload()); 	
//		}
//	}

	private void realRun(final ApplicationParameter params) throws IOException, Exception {
		logger.info("Starting ...");		
		final String filesPath = params.getPathOfPayload() + SUB_PATH_FILES;
				
		System.out.println("Start search LOAD DATA into general query log file");
		final List<Integer> idsWithLoadData = new SearchLoadDataStatement().run(params.generalQueryLogPath());
		
		System.out.println("Start load file name of Connections");
		final List<Integer> connectionFileNames = retriveConnectionFiles(new File(filesPath));
		
		if (idsWithLoadData.isEmpty()) {
			System.out.println("Start schedule of " + connectionFileNames.size() + " connection's");
			
			final List<TimerConnectionAggregator>  tcas = Lists.newArrayList();			
			for (Integer fileName : connectionFileNames) {
				tcas.add(new TimerConnectionAggregator(Long.valueOf(0l), Sets.newHashSet(fileName)));
			}
			
			schedule(params.getNumberOfThread(), tcas, filesPath, null, params.getDatabaseServer(), params.getPathOfPayload());											
		} else {
			logger.info("Start searching of real file name of LOAD DATA");
			final List<Integer> intersection = ListUtils.intersection(connectionFileNames, idsWithLoadData);
			final HashMap<Integer, String[]> run = new SearchLoadDataRealFileName().run(intersection, params.binaryLogDirPath());
			
			final List<TimerConnectionAggregator>  tcas = Lists.newArrayList();			
			for (Entry<Integer, String[]> e : run.entrySet()) {
				final TimerConnectionAggregator tca = new TimerConnectionAggregator(Long.valueOf(0l), Sets.newHashSet(e.getKey()));				
				tca.addLoadData(e.getKey(), e.getValue());
				
				tcas.add(tca);
			}
			
			System.out.println("Start schedule of " + connectionFileNames.size() + " connection's and " + idsWithLoadData.size() + " load data");
			schedule(params.getNumberOfThread(), tcas, filesPath, params.loadDataDirPath(), params.getDatabaseServer(), params.getPathOfPayload()); 	
		}
	}
	
	private List<Integer> retriveConnectionFiles(final File folder) {
		final List<Integer> result = new ArrayList<Integer>();
		
	    for (final File fileEntry : folder.listFiles()) {
	        if (!fileEntry.isDirectory()) {
	        	try {
		        	final Integer i = Integer.valueOf(fileEntry.getName());
		        	
		        	result.add(i);	        		
	        	} catch (NumberFormatException nfe) {	        			        		
	        	}
	        }
	    }
	    
	    Collections.sort(result);
	    
	    return result;
	}	

	private DataSource buildDataSource(String host) throws PropertyVetoException {
		final ComboPooledDataSource ds = new ComboPooledDataSource();
		
		ds.setDriverClass("com.mysql.jdbc.Driver");		
		ds.setJdbcUrl("jdbc:mysql://" + host + ":3306/"); //add ?profileSQL=true for profile all sql stament with c3p0
		ds.setUser("u_stressato");
		ds.setPassword("s3ssat0");
		
//		ds.setInitialPoolSize(10);
		ds.setAcquireIncrement(10);
		ds.setMaxPoolSize(100);
		ds.setMinPoolSize(10);	
		
		return ds;
	}	
	
	private void schedule(int numberOfThread, List<TimerConnectionAggregator> data, String filesPath, String loadDatasPath, String dbHostName, String generalLogDirPath) {
		final List<ScheduledFuture<PayloadAsync>> futureData = new ArrayList<ScheduledFuture<PayloadAsync>>();				
		final ScheduledExecutorService pool = Executors.newScheduledThreadPool(numberOfThread);
		
		//XXX make and add shutdown hook
		Runtime.getRuntime().addShutdownHook(new RunWhenShuttingDown(futureData, generalLogDirPath));
		
		try {
			final DataSource ds = buildDataSource(dbHostName);			
			
			for (TimerConnectionAggregator tca : data) {
				futureData.add(
					pool.schedule(
						new MyCallable(tca, filesPath, loadDatasPath, ds), 
						tca.getDelay(), 
						TimeUnit.MILLISECONDS
					)
				);
			}			
		} catch (PropertyVetoException e) {
			e.printStackTrace();
		}
		
		logger.info("thread pool shutdown");
		pool.shutdown();		
		
		try {
			logger.info("thread pool awaitTermination");
			pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}		
	}

//  > VERSION 1
//	private void schedule(int numberOfThread, List<TimerConnectionAggregator> data, String filesPath, String loadDatasPath, String dbHostName, String generalLogDirPath) {
//		final List<ScheduledFuture<PayloadAsync>> futureData = new ArrayList<ScheduledFuture<PayloadAsync>>();				
//		final ScheduledExecutorService pool = Executors.newScheduledThreadPool(numberOfThread);
//		
//		//XXX make and add shutdown hook
//		Runtime.getRuntime().addShutdownHook(new RunWhenShuttingDown(futureData, generalLogDirPath));
//		
//		try {
//			final DataSource ds = buildDataSource(dbHostName);			
//			long current = 0;
//			
//			//boolean noDelay = Boolean.parseBoolean(System.getProperty(ApplicationProperty.NO_DELAY.getPropertyName(), "false"));
//			
//			for (TimerConnectionAggregator tca : data) {
//				current += tca.getDelay();
//				
//				futureData.add(
//					pool.schedule(
//						new MyCallable(tca, filesPath, loadDatasPath, ds), 
//						current, 
//						TimeUnit.MILLISECONDS
//					)
//				);
//			}			
//		} catch (PropertyVetoException e) {
//			e.printStackTrace();
//		}
//		
//		logger.info("thread pool shutdown");
//		pool.shutdown();		
//		
//		try {
//			logger.info("thread pool awaitTermination");
//			pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
//		} catch (InterruptedException e) {
//			e.printStackTrace();
//		}
//	}
//
//  > VERSION 1	
//	private void delete(File file) throws IOException {
//		if (file.exists() && file.isDirectory()) {
//			// directory is empty, then delete it
//			if (file.list().length == 0) {
//				file.delete();
//			} else {
//				// list all the directory contents
//				final String files[] = file.list();
//
//				for (String temp : files) {
//					// construct the file structure
//					final File fileDelete = new File(file, temp);
//
//					// recursive delete
//					delete(fileDelete);
//				}
//
//				// check the directory again, if empty then delete it
//				if (file.list().length == 0) {
//					file.delete();
//				}
//			}
//		} else {
//			// if file, then delete it
//			file.delete();
//		}
//	}
}
