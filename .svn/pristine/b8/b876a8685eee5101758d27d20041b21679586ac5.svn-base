package runner.contactlab.com;

import java.beans.PropertyVetoException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.StringUtils;

import script.contactlab.com.PrintResult;
import script.contactlab.com.SearchLoadDataRealFileName;
import script.contactlab.com.SearchLoadDataStatement;
import script.contactlab.com.SplitGeneralQueryLogFile;
import script.contactlab.com.TimerConnectionAggregator;

import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class ApplicationRunner {

	private static final String SUB_PATH_LD = "/ld/";
	private static final String SUB_PATH_FILES = "/files/";
	
	private Logger logger;
	private final Scanner scanner;

	@Inject
	public ApplicationRunner(Logger logger) {
		this.logger = logger;
		this.scanner = new Scanner(System.in);
	}

	public void run() throws Exception {
		logger.info("Running ...");

		//numberOfThread PARAM
		Integer numberOfThread;
		try {
			logger.info("Number of Thread:");
			numberOfThread = new Integer(scanner.nextLine());
		} catch (NumberFormatException e) {
			logger.error("No number received, add default !!?");

			numberOfThread = 5;
		}
		logger.info("Supplied Number of Thread: " + numberOfThread);
				
		//serverName PARAM
		String serverName = null;
		while (StringUtils.isBlank(serverName)) {
			logger.info("Db Server:");
			serverName = scanner.nextLine();					
		}		
		logger.info("Supplied Db Server: " + serverName);
		
		logger.info("Absolute Path of general query log file: ");
		final String generalLogInput = scanner.nextLine();

		final File generalLog = new File(generalLogInput);
		if (isAccesible(generalLog)) {
			final List<ScheduledFuture<PayloadAsync>> scheduleResult;
			
			//make dir /files and empty if exist
			final File t = new File(generalLog.getParent() + SUB_PATH_FILES);		
			delete(t);			
			t.mkdir();
			
			final String filesPath = generalLog.getParent() + SUB_PATH_FILES;
			
			logger.info("Start splitter of general query log file");
			final List<TimerConnectionAggregator> data =
				new SplitGeneralQueryLogFile().run(generalLog.getAbsolutePath(), filesPath);
			
			logger.info("Start search LOAD DATA into general query log file");
			final List<Integer> idsWithLoadData = 
				new SearchLoadDataStatement().run(generalLogInput);
			
			if (idsWithLoadData.isEmpty()) {
				logger.info("Start schedule of " + data.size() + " connection's");
				scheduleResult = schedule(numberOfThread, data, filesPath, null, serverName);											
			} else {
				logger.info("Absolute Path of binary log file: (mysqlbinlog --verbose bin.000003 > bin.000003.txt)");
				final String binaryLogInput = scanner.nextLine();
				
				final File binaryLog = new File(binaryLogInput);
				if (isAccesible(binaryLog)) {
					
					logger.info("Start searching of real file name of LOAD DATA");
					for (TimerConnectionAggregator tca : data) {
						final List<Integer> intersection = ListUtils.intersection(Lists.newArrayList(tca.getIds()), idsWithLoadData);
						final HashMap<Integer, String[]> run = new SearchLoadDataRealFileName().run(intersection, binaryLogInput);
						
						for (Entry<Integer, String[]> e : run.entrySet()) {
							tca.addLoadData(e.getKey(), e.getValue());
						}
					}
					
					logger.info("Start schedule of " + data.size() + " connection's and " + idsWithLoadData.size() + " load data");
					scheduleResult = schedule(numberOfThread, data, filesPath, binaryLog.getParent() + SUB_PATH_LD, serverName); 																
				} else {
					logger.error("Can't load data from file: " + binaryLogInput);
					
					scheduleResult = new ArrayList<ScheduledFuture<PayloadAsync>>();
				}
			}		
			
			new PrintResult().print(scheduleResult, generalLog.getParent());
		} else {
			logger.error("Can't load data from file: " + generalLogInput);
		}

		scanner.close();
		logger.info("Running ... END'S !!");
	}


	private boolean isAccesible(final File generalLog) {
		return generalLog.exists() && generalLog.canRead();
	}
	
	private DataSource buildDataSource(String host) throws PropertyVetoException {
		final ComboPooledDataSource ds = new ComboPooledDataSource();
		
		ds.setDriverClass("com.mysql.jdbc.Driver");		
		//ds.setJdbcUrl("jdbc:mysql://" + host + ":3306/system");
		ds.setJdbcUrl("jdbc:mysql://" + host + ":3306/");
		ds.setUser("u_systest");
		ds.setPassword("tsetsys_u");
		
		//ds.setInitialPoolSize(10);
		ds.setAcquireIncrement(10);
		ds.setMaxPoolSize(100);
		ds.setMinPoolSize(10);	
		
		return ds;
	}	

	private List<ScheduledFuture<PayloadAsync>> schedule(
		int numberOfThread, List<TimerConnectionAggregator> data, String filesPath, String loadDatasPath, String dbHostName
	) {
		final List<ScheduledFuture<PayloadAsync>> futureData = new ArrayList<ScheduledFuture<PayloadAsync>>();
		final ScheduledExecutorService pool = Executors.newScheduledThreadPool(numberOfThread);
		
		try {
			final DataSource ds = buildDataSource(dbHostName);			
			long current = 0;
			
			for (TimerConnectionAggregator tca : data) {
				current += tca.getDelay();
				
				futureData.add(
					pool.schedule(
						new MyCallable(tca, filesPath, loadDatasPath, ds), current, TimeUnit.MILLISECONDS));
			}			
		} catch (PropertyVetoException e) {
			e.printStackTrace();
		}
		
		pool.shutdown();
		logger.info("... after pool shutdown");
		
		try {
			pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			logger.error(e.getMessage());
		}
		
		logger.info("... after pool awaitTermination");
		return futureData;
	}

	private void delete(File file) throws IOException {
		if (file.exists() && file.isDirectory()) {
			// directory is empty, then delete it
			if (file.list().length == 0) {
				file.delete();
			} else {
				// list all the directory contents
				final String files[] = file.list();

				for (String temp : files) {
					// construct the file structure
					final File fileDelete = new File(file, temp);

					// recursive delete
					delete(fileDelete);
				}

				// check the directory again, if empty then delete it
				if (file.list().length == 0) {
					file.delete();
				}
			}
		} else {
			// if file, then delete it
			file.delete();
		}
	}
}
