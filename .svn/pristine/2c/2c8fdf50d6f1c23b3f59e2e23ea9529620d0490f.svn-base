package script.contactlab.com;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import os.contactlab.com.ConnectionScanner;
import os.contactlab.com.LoadDataFileNameRepository;

import com.google.common.base.Optional;
import com.google.common.base.Stopwatch;

public class MyCallable implements Callable<PayloadAsync> {
	private static final Logger logger = LoggerFactory.getLogger(MyCallable.class);
	
	private TimerConnectionAggregator tca;
	private String filesPath;
	private String loadDatasPath;
	private DataSource ds;

	public MyCallable(TimerConnectionAggregator tca, String filesPath, String loadDatasPath, DataSource ds) {
		this.tca = tca;
		this.filesPath = filesPath;
		this.loadDatasPath = loadDatasPath;
		this.ds = ds;
	}

	@Override
	public PayloadAsync call() {
		final PayloadAsync result = new PayloadAsync();		
		
		for (Integer id : tca.getIds()) {
			Connection connection = null;
			try {
				printFileInformation(id);				
				connection = ds.getConnection();				
				executeAllStatementOf(id, connection, result);
			} catch (Exception e) {
				logger.error(e.getMessage() + " >> " + id);
			} finally {
				if (connection != null) {
					try {
						connection.close();
					} catch (SQLException e) {
					}						
				}
			}
		}
		
		result.buildStatisticalInfo();
		
		return result;
	}

	private void executeAllStatementOf(final Integer id, final Connection connection, final PayloadAsync result) throws Exception {
		for (String sql : new ConnectionScanner(filesPath + id).buildStatemens()) {
			String sqlStatement = null;
			
			if (StringUtils.contains(sql, LoadDataFileNameRepository.START_LOADDATA_STATEMENT)) {
				final String[] between = StringUtils.substringsBetween(
					sql, LoadDataFileNameRepository.START_LOADDATA_STATEMENT, LoadDataFileNameRepository.END_LOADDATA_STATEMENT
				);
				
				if (between.length != 1) {
					logger.error("Can't execute LOAD DATA with pattern: " + Arrays.toString(between));
				} else {											
					final Optional<String> loadDataFileName = tca.getLoadData(id);
					
					if (loadDataFileName.isPresent()) {
						sqlStatement = StringUtils.replace(sql, between[0], loadDatasPath + loadDataFileName.get());
					} else {
						logger.error("For " + sql + " can't find load data file name");
					}
				}
			} else {
				sqlStatement = sql;
			}
			
			if (StringUtils.isNotBlank(sqlStatement)) {
				result.addExecutionTime(id, realExecute(sqlStatement, connection));
			}
		}
	}
	
	private long realExecute(String sql, final Connection connection) {
		final Stopwatch sw = Stopwatch.createStarted();		
		executeStatement(sql, connection);		
		sw.stop();					
		
		return sw.elapsed(TimeUnit.MILLISECONDS);		
	}

	private void printFileInformation(Integer id) throws FileNotFoundException, IOException {
		final LineNumberReader lnr = new LineNumberReader(
			new BufferedReader(new InputStreamReader(
				new FileInputStream(filesPath + id)
			))
		);
					
		lnr.skip(Long.MAX_VALUE);
		logger.debug("On connection: " + id + " found " + lnr.getLineNumber() + " statement to be executed !!");
		lnr.close();
	}

	private void executeStatement(String sql, final Connection connection) {
		Statement stmt = null;
		
		try {			
			if (StringUtils.startsWith(sql, ParsingUtil.USE)) {
				connection.setCatalog(StringUtils.split(sql, " ")[1]); 
			} else {
				stmt = connection.createStatement();
				stmt.execute(sql);
			}			
		} catch (Exception ex) {
			logger.error(ex.getMessage() + " >> " + StringUtils.substring(sql, 0, 20));
		} finally {
			if (stmt != null) {
				try {
					stmt.close();
				} catch (SQLException e) {					
				}				
			}
		}
	}
	
//	public static void main(String[] args) {		
//		String sql1 = "LOAD DATA LOCAL INFILE \"/u/data/contactlab/tmp/1421746171.217\" INTO TABLE DB_3860 FIELDS TERMINATED BY ';' OPTIONALLY ENCLOSED BY '\"' LINES TERMINATED BY '' IGNORE 1 LINES (`Email`,`Nome`,`Cognome`,`Regione`,`Sesso`)";			
//		String sql2 = "LOAD DATA LOCAL INFILE 'C:\\tmp\\jboss\\AP\\fileOperations\\3000116\\7935\\fileOperation4880993734274841690.1421746355218.csv' INTO TABLE FILE_OP_7935_ FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' ESCAPED BY '\\' LINES TERMINATED BY '\n' IGNORE 0 LINES (PK_ID,PUSH_KEY,Field_2,push_endpoint_field,Field_4)";
//		String sql3 = "LOAD DATA LOCAL INFILE '/tmp/jboss/AP/fileOperations/3000116/7935/Selected_Records.csv' INTO TABLE DB_6394 FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"' ESCAPED BY '\\' LINES TERMINATED BY '' IGNORE 0 LINES (PUSH_KEY,Field_2,push_endpoint_field,Field_4)";	
//		
//		System.out.println(Arrays.toString(StringUtils.substringsBetween(sql1, SearchLoadDataRealFileName.START_LOADDATA_STATEMENT, SearchLoadDataRealFileName.END_LOADDATA_STATEMENT)));
//		System.out.println(Arrays.toString(StringUtils.substringsBetween(sql2, SearchLoadDataRealFileName.START_LOADDATA_STATEMENT, SearchLoadDataRealFileName.END_LOADDATA_STATEMENT)));
//		System.out.println(Arrays.toString(StringUtils.substringsBetween(sql3, SearchLoadDataRealFileName.START_LOADDATA_STATEMENT, SearchLoadDataRealFileName.END_LOADDATA_STATEMENT)));
//	}
}
