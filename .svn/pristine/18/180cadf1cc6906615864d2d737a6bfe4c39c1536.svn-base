package runner.contactlab.com;

import java.beans.PropertyVetoException;
import java.util.Collection;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import script.contactlab.com.ApplicationParameter;
import script.contactlab.com.ApplicationParameterHandler;
import script.contactlab.com.PartialResultWriter;

import com.mchange.v2.c3p0.ComboPooledDataSource;

public abstract class ApplicationRunner {
	protected static final Logger logger = LoggerFactory.getLogger(ApplicationRunner.class);
	public static final String SUB_PATH_FILES = "/files/";
	
	public void run() throws Exception {
		logger.info("Give me application parameters ...");
		final ApplicationParameter params = new ApplicationParameterHandler().run();

		realRun(params);		
	}
	
	public void run(final ApplicationParameter params) throws Exception {
		realRun(params);
	}
	
	protected abstract void realRun(final ApplicationParameter params) throws Exception; 

	protected DataSource buildDataSource(String host, int numberOfThread) throws PropertyVetoException {
		final ComboPooledDataSource ds = new ComboPooledDataSource();
		
		ds.setDriverClass("com.mysql.jdbc.Driver");		
		ds.setJdbcUrl("jdbc:mysql://" + host + ":3306/"); //add ?profileSQL=true for profile all sql stament with c3p0
		ds.setUser("u_stressato");
		ds.setPassword("s3ssat0");
						
		ds.setMinPoolSize(numberOfThread);		
		ds.setMaxPoolSize(numberOfThread * 2);
		ds.setAcquireIncrement(5);
				
		ds.setAcquireRetryAttempts(3); //Defines how many times c3p0 will try to acquire a new Connection from the database before giving up. If this value is less than or equal to zero, c3p0 will keep trying to fetch a Connection indefinitely.
		ds.setMaxIdleTime(5); //Seconds a Connection can remain pooled but unused before being discarded. Zero means idle connections never expire.
		
		return ds;
	}	
	
	protected void addHookForCancelTask(final Collection<? extends Future<PayloadAsync>> futureData) {
		//XXX make and add shutdown hook
		Runtime.getRuntime().addShutdownHook(new Thread() {
			@Override
			public void run() {
				logger.info("END'S !!");
				
				/*
				  se durante l'esecuzione dei thread che eseguono gli statement
				  un ctlr-c è intercettato ...
				   
				  cancello le altre schedulazioni che non hanno ancora eseguito le operazioni
				  e stampo solo quello che è stato eseguito veramente!!?
				  
				  altrimenti la cancellazione di un thread che ha già terminato 
				  non ha alcun effetto.
				 */
				
				for (Future<PayloadAsync> scheduledFuture : futureData) {
					scheduledFuture.cancel(true);
				}				
			}
		});		
	}
	
}
